{"version":3,"sources":["webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/blocks.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/admonition.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/figure.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/index.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/math.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/options.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/plugin.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/types.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/directives/utils.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/index.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/math/amsmath.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/math/index.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/math/utils.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/myst.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/plugins.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/generic.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/html.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/index.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/math.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/plugin.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/roles/references.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/state.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/dist/src/utils.js","webpack://jupyterlab-myst/./node_modules/markdown-it-myst/node_modules/markdown-it-container/index.js","webpack://jupyterlab-myst/./node_modules/markdown-it-texmath/texmath.js"],"names":[],"mappings":";;;;;;;;;AAAa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,gBAAgB,mBAAO,CAAC,oFAA8B;AACtD,gBAAgB,mBAAO,CAAC,kEAAS;AACjC;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D,QAAQ;AACR,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wDAAwD,wEAAwE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;;;;;;ACrIa;AACb;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,6EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,oBAAoB;AACpB,SAAS;AACT;AACA,mBAAmB,uBAAuB;AAC1C;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,uBAAuB;AAC1C;AACA,0BAA0B,iDAAiD;AAC3E,4BAA4B,kBAAkB;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,sC;;;;;;;;;;;AC5Da;AACb;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,gBAAgB,mBAAO,CAAC,6EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,oBAAoB;AACpB,SAAS;AACT;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,mBAAmB,MAAM;AACzB,mBAAmB,aAAa;AAChC;AACA,2BAA2B,wBAAwB;AACnD,yBAAyB,MAAM;AAC/B,gCAAgC,SAAS;AACzC;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,kC;;;;;;;;;;;ACzCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,kBAAkB;AACnC,qCAAqC,mBAAO,CAAC,uFAAc;AAC3D,iCAAiC,mBAAO,CAAC,+EAAU;AACnD,+BAA+B,mBAAO,CAAC,2EAAQ;AAC/C,kBAAkB,+CAA+C;AACjE,eAAe,mBAAO,CAAC,+EAAU;AACjC,0CAAyC,CAAC,qCAAqC,wBAAwB,EAAE,EAAE,EAAC;AAC5G,iC;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,gBAAgB,mBAAO,CAAC,6EAAS;AACjC;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS,eAAe;AACtD;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,gC;;;;;;;;;;;ACtCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,6EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,IAAI,IAAI,UAAU,OAAO,aAAa;AACtG;AACA;AACA;AACA,KAAK;AACL,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,oDAAoD,iBAAiB,OAAO;AAC5E;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA,gDAAgD,iBAAiB,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,mC;;;;;;;;;;;ACvFa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,gDAAgD,mBAAO,CAAC,0GAAuB;AAC/E,kCAAkC,mBAAO,CAAC,iFAAW;AACrD,gBAAgB,mBAAO,CAAC,6EAAS;AACjC,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA,cAAc,OAAO,EAAE,cAAc,EAAE,MAAM;AAC7C;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,uDAAuD,gBAAgB,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,uDAAuD,gBAAgB,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,GAAG,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;;;;;;AChLa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E,iC;;;;;;;;;;;ACVa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA,4BAA4B;AAC5B,iC;;;;;;;;;;;ACTa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,aAAa,GAAG,eAAe,GAAG,YAAY;AACnE,6BAA6B,mBAAO,CAAC,sEAAW;AAChD,eAAe;AACf,gBAAgB,mBAAO,CAAC,wEAAS;AACjC,yCAAwC,CAAC,qCAAqC,sBAAsB,EAAE,EAAE,EAAC;AACzG,qBAAqB,mBAAO,CAAC,kFAAc;AAC3C,8CAA6C,CAAC,qCAAqC,gCAAgC,EAAE,EAAE,EAAC;AACxH,aAAa,mBAAO,CAAC,gEAAQ;AAC7B,wCAAuC,CAAC,qCAAqC,wCAAwC,EAAE,EAAE,EAAC;AAC1H,iC;;;;;;;;;;;ACjCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,uEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG,uBAAuB,QAAQ;AACzE;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,YAAY,EAAE,UAAU;AACjD;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,WAAW;AACtB,kEAAkE,wEAAwE;AAC1I;AACA;AACA,eAAe;AACf,mC;;;;;;;;;;;ACpGa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,wBAAwB;AACzC,8CAA8C,mBAAO,CAAC,0EAAqB;AAC3E,kCAAkC,mBAAO,CAAC,2EAAW;AACrD,gBAAgB,mBAAO,CAAC,uEAAS;AACjC;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd,iC;;;;;;;;;;;ACjCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB,gBAAgB,mBAAO,CAAC,mEAAU;AAClC;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,sCAAsC,KAAK,eAAe,KAAK;AAC/D,SAAS,IAAI,eAAe;AAC5B,sBAAsB,KAAK;AAC3B;AACA,kBAAkB;AAClB,iC;;;;;;;;;;;ACfa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,yCAAyC,6BAA6B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,sBAAsB;AACtB,sCAAsC,mBAAO,CAAC,4EAAa;AAC3D,6BAA6B,mBAAO,CAAC,sEAAW;AAChD,qBAAqB,mBAAO,CAAC,kFAAc;AAC3C,gBAAgB,mBAAO,CAAC,wEAAS;AACjC,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,gC;;;;;;;;;;;AC7Ca;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,aAAa,GAAG,YAAY,GAAG,cAAc;AAClE,eAAe,mBAAO,CAAC,oEAAU;AACjC,0CAAyC,CAAC,qCAAqC,wBAAwB,EAAE,EAAE,EAAC;AAC5G,aAAa,mBAAO,CAAC,sEAAQ;AAC7B,wCAAuC,CAAC,qCAAqC,sBAAsB,EAAE,EAAE,EAAC;AACxG,cAAc,mBAAO,CAAC,wEAAS;AAC/B,yCAAwC,CAAC,qCAAqC,uBAAuB,EAAE,EAAE,EAAC;AAC1G,mBAAmB,mBAAO,CAAC,kFAAc;AACzC,8CAA6C,CAAC,qCAAqC,4BAA4B,EAAE,EAAE,EAAC;AACpH,mC;;;;;;;;;;;ACXa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,mEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iCAAiC,EAAE,MAAM,IAAI,cAAc,KAAK;AACjF,gBAAgB,eAAe;AAC/B;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,mC;;;;;;;;;;;ACnBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,cAAc;AAC/C;AACA,oBAAoB,SAAS,sBAAsB;AACnD,SAAS;AACT;AACA;AACA,oDAAoD,yDAAyD,IAAI,eAAe;AAChI;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,mDAAmD,gCAAgC,IAAI,eAAe;AACtG;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,mDAAmD,gCAAgC,IAAI,eAAe;AACtG;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,gC;;;;;;;;;;;ACpCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,aAAa;AAC9B,+BAA+B,mBAAO,CAAC,sEAAQ;AAC/C,+BAA+B,mBAAO,CAAC,sEAAQ;AAC/C,qCAAqC,mBAAO,CAAC,kFAAc;AAC3D,kCAAkC,mBAAO,CAAC,4EAAW;AACrD,aAAa,6DAA6D;AAC1E,eAAe,mBAAO,CAAC,0EAAU;AACjC,0CAAyC,CAAC,qCAAqC,wBAAwB,EAAE,EAAE,EAAC;AAC5G,iC;;;;;;;;;;;ACba;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,6EAAe;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf,gC;;;;;;;;;;;ACVa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc;AACd,kCAAkC,mBAAO,CAAC,4EAAW;AACrD;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA,wBAAwB,gBAAgB,KAAK,IAAI;AACjD;AACA;AACA;AACA;AACA,YAAY,eAAe,KAAK,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,gBAAgB,2EAA2E;AAC3F;AACA,YAAY,kFAAkF;AAC9F;AACA;AACA,WAAW,WAAW;AACtB,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uDAAuD;AACvD,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kC;;;;;;;;;;;ACjEa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC,oCAAoC,IAAI;AACxC,SAAS;AACT,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA,kBAAkB,cAAc,GAAG,OAAO;AAC1C;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA,SAAS;AACT,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS,eAAe;AACxC;AACA,YAAY,SAAS,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE,KAAK;AACL;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE,KAAK;AACL;AACA;AACA;AACA,mCAAmC,oEAAoE;AACvG,KAAK;AACL;AACA,eAAe;AACf,sC;;;;;;;;;;;ACpEa;AACb;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB,GAAG,kBAAkB;AAC5D,gBAAgB,mBAAO,CAAC,oFAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA,aAAa,YAAY,GAAG,GAAG,EAAE;AACjC,iBAAiB,cAAc,IAAI,EAAE,EAAE;AACvC,kBAAkB,eAAe,IAAI,EAAE,EAAE;AACzC,oBAAoB,iBAAiB,IAAI,EAAE,EAAE;AAC7C,mBAAmB,gBAAgB,IAAI,EAAE,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,eAAe,aAAa,gBAAgB,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK,GAAG,eAAe;AAChF,yBAAyB,KAAK,GAAG,4BAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iC;;;;;;;;;;;AC1Ea;AACb;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,iBAAiB;AAClC,gBAAgB,mBAAO,CAAC,oFAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI,IAAI,sBAAsB;AAC5C;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB,EAAE,YAAY,MAAM,OAAO;AACxE;AACA,kBAAkB,KAAK,EAAE,KAAK,EAAE,qCAAqC;AACrE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gEAAgE,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,eAAe,OAAO,EAAE,KAAK,cAAc,MAAM,EAAE,KAAK;AACxD;AACA,cAAc;AACd,iC;;;;;;;;;;;AClIA;AACA;AACa;;;AAGb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,cAAc;;AAEpE;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,cAAc;AACnD;;AAEA;AACA;AACA,oCAAoC,cAAc;;AAElD;AACA;AACA,iBAAiB,aAAa;;AAE9B;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,UAAU;;AAElE;AACA;AACA;AACA;;AAEA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,UAAU;;AAE5E;AACA;AACA;;AAEA,sBAAsB,UAAU;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACa;;AAEb;AACA;AACA,6DAA6D;AAC7D,2EAA2E;;AAE3E,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB,IAA0B;AAC3C,4BAA4B,mBAAO,CAAC,0DAAO;AAC3C;AACA,YAAY,EAA0E;AACtF;;AAEA;AACA;AACA,8EAA8E;AAC9E;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;;AAEA,kB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;;AAEA,mCAAmC,mBAAmB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,cAAc,EAAE;;AAEpC;AACA;AACA;;AAEA,2DAA2D,OAAO;;AAElE;;AAEA;;AAEA;AACA;;AAEA,uEAAuE,YAAY;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,EAAE,qBAAqB,EAAE;AACjD;AACA;AACA,aAAa;AACb,aAAa;AACb,wBAAwB,EAAE,oBAAoB,EAAE;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb,wBAAwB,EAAE,UAAU,EAAE;AACtC;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,EAAE,sBAAsB,EAAE;AAClD;AACA;AACA,aAAa;AACb,aAAa;AACb,wBAAwB,EAAE,sBAAsB,EAAE;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb,yBAAyB,EAAE,QAAQ,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yBAAyB,EAAE,WAAW,EAAE;AACxC;AACA;AACA,aAAa;AACb,aAAa;AACb,yBAAyB,EAAE,WAAW,EAAE;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb,yBAAyB,EAAE,uBAAuB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yBAAyB,EAAE,WAAW,EAAE;AACxC;AACA;AACA,aAAa;AACb,aAAa;AACb,yBAAyB,EAAE,WAAW,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,KAA0B;AAC9B,4B","file":"vendors-node_modules_markdown-it-myst_dist_src_index_js.1dfc8d9dfce919fbe4b4.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = void 0;\nconst utils_1 = require(\"markdown-it/lib/common/utils\");\nconst state_1 = require(\"./state\");\n// % A comment\nconst COMMENT_PATTERN = /^%\\s(.*)$/;\n// (my_id)=\nconst TARGET_PATTERN = /^\\(([a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/;\n// +++ {\"meta\": \"data\"}\nconst BLOCK_BREAK_PATTERN = /^\\+\\+\\+\\s?(\\{.*\\})?$/;\nfunction checkTarget(state, startLine, str, silent) {\n    var _a;\n    const match = TARGET_PATTERN.exec(str);\n    if (match == null)\n        return false;\n    if (silent)\n        return true;\n    state.line = startLine + 1;\n    const token = state.push('myst_target', '', 0);\n    const id = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '';\n    token.attrSet('id', id);\n    token.map = [startLine, state.line];\n    state_1.newTarget(state, id, state_1.TargetKind.ref);\n    return true;\n}\nfunction checkComment(state, startLine, str, silent) {\n    var _a;\n    const match = COMMENT_PATTERN.exec(str);\n    if (match == null)\n        return false;\n    if (silent)\n        return true;\n    state.line = startLine + 1;\n    const token = state.push('myst_comment', '', 0);\n    const comment = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '';\n    token.attrSet('comment', comment);\n    token.map = [startLine, state.line];\n    return true;\n}\nfunction checkBlockBreak(state, startLine, str, silent) {\n    var _a;\n    const match = BLOCK_BREAK_PATTERN.exec(str);\n    if (match == null)\n        return false;\n    if (silent)\n        return true;\n    state.line = startLine + 1;\n    const token = state.push('myst_block_break', '', 0);\n    const metadataString = (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '{}';\n    let metadata = {};\n    try {\n        metadata = JSON.parse(metadataString);\n    }\n    catch (error) {\n        console.warn('Could not parse metadata for block break: ', metadataString);\n    }\n    token.meta = Object.assign(Object.assign({}, token.meta), { metadata });\n    token.map = [startLine, state.line];\n    return true;\n}\nconst blockPlugins = [checkTarget, checkComment, checkBlockBreak];\nfunction blocks(state, startLine, endLine, silent) {\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const maximum = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4)\n        return false;\n    const str = state.src.slice(pos, maximum);\n    return blockPlugins.reduce((complete, plug) => (complete || plug(state, startLine, str, silent)), false);\n}\nconst renderTarget = (tokens, idx, opts, env) => {\n    var _a, _b;\n    const ref = (_a = tokens[idx].attrGet('id')) !== null && _a !== void 0 ? _a : '';\n    const id = (_b = env.targets[ref]) === null || _b === void 0 ? void 0 : _b.id;\n    // TODO: This should be better as part of the next element, and then hide this\n    return (`<span id=\"${id}\"></span>\\n`);\n};\nconst renderComment = (tokens, idx) => {\n    var _a;\n    const comment = (_a = tokens[idx].attrGet('comment')) !== null && _a !== void 0 ? _a : '';\n    return (`<!-- ${utils_1.escapeHtml(comment)} -->\\n`);\n};\nconst renderBlockBreak = (tokens, idx) => {\n    const { metadata } = tokens[idx].meta;\n    console.log('Not sure what to do with metadata for block break:', metadata);\n    return ('<!-- Block Break -->\\n');\n};\nconst addBlockTitles = (state) => {\n    var _a;\n    const { tokens } = state;\n    const env = state_1.getStateEnv(state);\n    for (let index = 0; index < tokens.length; index += 1) {\n        const prev = tokens[index - 1];\n        const token = tokens[index];\n        const next = tokens[index + 1];\n        if ((prev === null || prev === void 0 ? void 0 : prev.type) === 'myst_target' && token.type === 'heading_open') {\n            const id = (_a = prev.attrGet('id')) !== null && _a !== void 0 ? _a : '';\n            // TODO: Should likely have this actually be the rendered content?\n            env.targets[id].title = utils_1.escapeHtml(next.content);\n        }\n    }\n    return true;\n};\nconst updateLinkHrefs = (state) => {\n    const { tokens } = state;\n    const env = state_1.getStateEnv(state);\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token.type === 'inline' && token.children) {\n            token.children.forEach((t) => {\n                var _a, _b;\n                if (t.type === 'link_open') {\n                    const target = env.targets[(_a = t.attrGet('href')) !== null && _a !== void 0 ? _a : ''];\n                    if (target) {\n                        t.attrSet('title', (_b = target.title) !== null && _b !== void 0 ? _b : '');\n                        t.attrSet('href', `#${target.id}`);\n                    }\n                }\n            });\n        }\n    }\n    return true;\n};\nfunction plugin(md) {\n    md.block.ruler.before('hr', 'myst_blocks', blocks, { alt: ['paragraph', 'reference', 'blockquote', 'list', 'footnote_def'] });\n    md.core.ruler.after('block', 'add_block_titles', addBlockTitles);\n    md.core.ruler.after('inline', 'update_link_hrefs', updateLinkHrefs);\n    md.renderer.rules.myst_target = renderTarget;\n    md.renderer.rules.myst_comment = renderComment;\n    md.renderer.rules.myst_block_break = renderBlockBreak;\n}\nexports.plugin = plugin;\n//# sourceMappingURL=blocks.js.map","\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst admonitionTitles = {\n    attention: 'Attention', caution: 'Caution', danger: 'Danger', error: 'Error', important: 'Important', hint: 'Hint', note: 'Note', seealso: 'See Also', tip: 'Tip', warning: 'Warning',\n};\nconst DEFAULT_ADMONITION_CLASS = 'note';\nconst createAdmonition = (kind) => {\n    const className = kind === 'admonition' ? DEFAULT_ADMONITION_CLASS : kind;\n    return {\n        token: kind,\n        getArguments: (info) => {\n            const content = kind === 'admonition' ? '' : info;\n            const title = kind === 'admonition' ? info : admonitionTitles[kind];\n            const args = { title };\n            return { args, content };\n        },\n        getOptions: (data) => {\n            const { class: overrideClass } = data, rest = __rest(data, [\"class\"]);\n            utils_1.unusedOptionsWarning(kind, rest);\n            return { class: overrideClass };\n        },\n        renderer: (args, opts) => {\n            const { title } = args;\n            const { class: overrideClass } = opts;\n            return [\n                'aside', { class: ['callout', overrideClass || className] },\n                ['header', { children: title }],\n                0,\n            ];\n        },\n    };\n};\nconst admonitions = {\n    admonition: createAdmonition('admonition'),\n    callout: createAdmonition('admonition'),\n    // All other admonitions\n    attention: createAdmonition('attention'),\n    caution: createAdmonition('caution'),\n    danger: createAdmonition('danger'),\n    error: createAdmonition('error'),\n    important: createAdmonition('important'),\n    hint: createAdmonition('hint'),\n    note: createAdmonition('note'),\n    seealso: createAdmonition('seealso'),\n    tip: createAdmonition('tip'),\n    warning: createAdmonition('warning'),\n};\nexports.default = admonitions;\n//# sourceMappingURL=admonition.js.map","\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst state_1 = require(\"../state\");\nconst utils_1 = require(\"./utils\");\nconst figure = {\n    figure: {\n        token: 'figure',\n        numbered: state_1.TargetKind.figure,\n        autoNumber: true,\n        getArguments: (info) => {\n            const args = { src: info.trim() };\n            return { args, content: '' };\n        },\n        getOptions: (data) => {\n            const { name } = data, rest = __rest(data, [\"name\"]);\n            utils_1.unusedOptionsWarning('figure', rest);\n            return { name };\n        },\n        renderer: (args, opts, target) => {\n            const { src } = args;\n            const { id, number } = target !== null && target !== void 0 ? target : {};\n            return [\n                'figure', { id, class: 'numbered' },\n                ['img', { src }],\n                ['figcaption', { number }, 0],\n            ];\n        },\n    },\n};\nexports.default = figure;\n//# sourceMappingURL=figure.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = exports.directives = void 0;\nconst admonition_1 = __importDefault(require(\"./admonition\"));\nconst figure_1 = __importDefault(require(\"./figure\"));\nconst math_1 = __importDefault(require(\"./math\"));\nexports.directives = Object.assign(Object.assign(Object.assign({}, admonition_1.default), figure_1.default), math_1.default);\nvar plugin_1 = require(\"./plugin\");\nObject.defineProperty(exports, \"plugin\", { enumerable: true, get: function () { return plugin_1.plugin; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst state_1 = require(\"../state\");\nconst utils_1 = require(\"./utils\");\nconst math = {\n    math: {\n        token: 'math',\n        numbered: state_1.TargetKind.equation,\n        skipParsing: true,\n        getArguments: () => ({ args: {}, content: '' }),\n        getOptions: (data) => {\n            // See https://github.com/sphinx-doc/sphinx/issues/8476\n            const { name, label } = data, rest = __rest(data, [\"name\", \"label\"]);\n            utils_1.unusedOptionsWarning('math', rest);\n            return { name: name || label };\n        },\n        renderer: (args, opts, target) => {\n            const { id, number } = target !== null && target !== void 0 ? target : {};\n            return ['div', {\n                    class: target ? ['math', 'numbered'] : 'math',\n                    id,\n                    number,\n                }, 0];\n        },\n    },\n};\nexports.default = math;\n//# sourceMappingURL=math.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = require(\"./types\");\nconst QUICK_PARAMETERS = /^:([a-zA-Z0-9\\-_]+):(.*)$/;\nfunction stripParams(content) {\n    const data = {};\n    let stopParams = false;\n    const modified = content.split('\\n').reduce((lines, line) => {\n        const match = line.match(QUICK_PARAMETERS);\n        if (stopParams || !match) {\n            stopParams = true;\n            return [...lines, line];\n        }\n        const [, key, value] = match;\n        if (data[key] !== undefined) {\n            console.warn(`There are multiple keys defined for ${key}: ${data[key]} and ${value.trim()}`);\n        }\n        data[key] = value.trim();\n        return lines;\n    }, []);\n    return { data, modified: modified.join('\\n') };\n}\nfunction stripYaml(content) {\n    const data = {};\n    return { data, modified: content };\n}\nfunction addDirectiveOptions(directive, parent, tokens, index, isFence = false) {\n    const [open, token, close] = tokens.slice(index - 1, index + 2);\n    const useToken = isFence ? parent : token;\n    const { content } = useToken;\n    const firstLine = content.split('\\n')[0].trim();\n    const isYaml = firstLine === '---';\n    const isQuickParams = QUICK_PARAMETERS.test(firstLine);\n    if (!isYaml && !isQuickParams) {\n        const opts = directive.getOptions({});\n        // eslint-disable-next-line no-param-reassign\n        parent.meta = Object.assign(Object.assign({}, parent.meta), { opts });\n        return;\n    }\n    const strip = isYaml ? stripYaml : stripParams;\n    const { data, modified } = strip(useToken.content);\n    const opts = directive.getOptions(data);\n    // eslint-disable-next-line no-param-reassign\n    parent.meta = Object.assign(Object.assign({}, parent.meta), { opts });\n    useToken.content = modified;\n    // Here we will stop the tags from rendering if there is no content that is not metadata\n    // This stops empty paragraph tags from rendering.\n    const noContent = modified.length === 0;\n    if (!isFence && open && noContent)\n        open.hidden = true;\n    useToken.hidden = noContent;\n    if (!isFence && close && noContent)\n        close.hidden = true;\n}\nconst parseOptions = (directives) => (state) => {\n    var _a, _b;\n    const { tokens } = state;\n    let parent = false;\n    let directive = false;\n    let gotOptions = false;\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token.type === types_1.DirectiveTokens.open) {\n            directive = directives[(_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : ''];\n            parent = token;\n            gotOptions = false;\n        }\n        if (token.type === types_1.DirectiveTokens.close) {\n            if (parent) {\n                // Ensure there is metadata always defined for containers\n                const meta = Object.assign({ opts: {} }, parent.meta);\n                parent.meta = meta;\n                token.meta = meta;\n            }\n            parent = false;\n        }\n        if (token.type === types_1.DirectiveTokens.fence) {\n            addDirectiveOptions(directives[(_b = token.attrGet('kind')) !== null && _b !== void 0 ? _b : ''], token, tokens, index, true);\n        }\n        if (parent && !gotOptions && token.type === 'inline') {\n            addDirectiveOptions(directive, parent, tokens, index);\n            gotOptions = true;\n        }\n    }\n    return true;\n};\nexports.default = parseOptions;\n//# sourceMappingURL=options.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = void 0;\nconst markdown_it_container_1 = __importDefault(require(\"markdown-it-container\"));\nconst options_1 = __importDefault(require(\"./options\"));\nconst types_1 = require(\"./types\");\nconst state_1 = require(\"../state\");\nconst utils_1 = require(\"../utils\");\nconst DIRECTIVE_PATTERN = /^\\{([a-z]*)\\}\\s*(.*)$/;\nfunction getDirective(directives, kind) {\n    if (!kind)\n        return undefined;\n    return directives[kind];\n}\n/**\n * Container that continues to render internally.\n *\n * For not rendering the internals (e.g. math), use `skipParsing`\n * and the directive will modify a `fence` renderer.\n *\n * @param directives The directives to use\n */\nconst directiveContainer = (directives) => ({\n    marker: '`',\n    validate(params) {\n        const match = params.trim().match(DIRECTIVE_PATTERN);\n        if (!match)\n            return false;\n        const kind = match[1];\n        const directive = getDirective(directives, kind);\n        return Boolean(directive) && !(directive === null || directive === void 0 ? void 0 : directive.skipParsing);\n    },\n    render(tokens, idx, options, env, self) {\n        var _a;\n        const token = tokens[idx];\n        const kind = (_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : '';\n        const directive = getDirective(directives, kind);\n        const { args, opts, target } = token.meta;\n        const htmlTemplate = directive.renderer(args, opts, target, tokens, idx, options, env, self);\n        const [before, after] = utils_1.toHTML(htmlTemplate);\n        return token.nesting === 1 ? before : after;\n    },\n});\n/**\n * This overrides the `fence` when `skipParsing` is set to true on a directive.\n *\n * @param directives The directives to use\n */\nconst fenceRenderer = (directives) => (tokens, idx, options, env, self) => {\n    var _a;\n    const token = tokens[idx];\n    const kind = (_a = token.attrGet('kind')) !== null && _a !== void 0 ? _a : '';\n    const directive = getDirective(directives, kind);\n    const { args, opts, target } = token.meta;\n    const htmlTemplate = directive.renderer(args, opts, target, tokens, idx, options, env, self);\n    const [before, after] = utils_1.toHTML(htmlTemplate);\n    return `${before}${token.content}${after}`;\n};\nconst setDirectiveKind = (directives) => (state) => {\n    var _a, _b;\n    const { tokens } = state;\n    let kind = false;\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token.type === types_1.DirectiveTokens.open) {\n            const match = token.info.trim().match(DIRECTIVE_PATTERN);\n            const directive = getDirective(directives, (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : '');\n            if (!directive)\n                throw new Error('Shoud not be able to get into here without having directive.');\n            kind = directive.token;\n            token.attrSet('kind', kind);\n        }\n        if (token.type === 'fence') {\n            // Here we match the directives that `skipParsing`, and turn them into `directive_fences`\n            // The options are then added as normal, the rendering is done in `fenceRenderer`\n            const match = token.info.trim().match(DIRECTIVE_PATTERN);\n            const directive = getDirective(directives, (_b = match === null || match === void 0 ? void 0 : match[1]) !== null && _b !== void 0 ? _b : '');\n            if (directive && directive.skipParsing) {\n                token.type = types_1.DirectiveTokens.fence;\n                kind = directive.token;\n                token.attrSet('kind', kind);\n            }\n        }\n        if (token.type === types_1.DirectiveTokens.close) {\n            // Set the kind on the closing container as well, as that will have to render the closing tags\n            token.attrSet('kind', kind);\n            kind = false;\n        }\n    }\n    return true;\n};\nconst parseArguments = (directives) => (state) => {\n    var _a, _b, _c, _d;\n    const { tokens } = state;\n    let parent = false;\n    // If there is a title on the first line when not required, bump it to the first inline\n    let bumpArguments = '';\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token.type === types_1.DirectiveTokens.open) {\n            parent = token;\n            const match = token.info.trim().match(DIRECTIVE_PATTERN);\n            const directive = getDirective(directives, token.attrGet('kind'));\n            if (!match || !directive)\n                throw new Error('Shoud not be able to get into here without matching?');\n            const info = match[2].trim();\n            const { args, content: modified } = (_b = (_a = directive.getArguments) === null || _a === void 0 ? void 0 : _a.call(directive, info)) !== null && _b !== void 0 ? _b : {};\n            token.meta = Object.assign(Object.assign({}, token.meta), { args });\n            if (modified)\n                bumpArguments = modified;\n        }\n        if (token.type === types_1.DirectiveTokens.fence) {\n            const match = token.info.trim().match(DIRECTIVE_PATTERN);\n            const directive = getDirective(directives, token.attrGet('kind'));\n            if (!match || !directive)\n                throw new Error('Shoud not be able to get into here without matching?');\n            const info = match[2].trim();\n            const { args, content: modified } = (_d = (_c = directive.getArguments) === null || _c === void 0 ? void 0 : _c.call(directive, info)) !== null && _d !== void 0 ? _d : {};\n            token.meta = Object.assign(Object.assign({}, token.meta), { args });\n            if (modified)\n                token.content = modified + token.content;\n        }\n        if (parent && token.type === types_1.DirectiveTokens.close) {\n            // TODO: https://github.com/executablebooks/MyST-Parser/issues/154\n            // If the bumped title needs to be rendered - put it here somehow.\n            bumpArguments = '';\n            token.meta = parent.meta;\n            parent = false;\n        }\n        if (parent && bumpArguments && token.type === 'inline') {\n            token.content = `${bumpArguments} ${token.content}`;\n            bumpArguments = '';\n        }\n    }\n    return true;\n};\nconst numbering = (directives) => (state) => {\n    var _a;\n    const { tokens } = state;\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (token.type === types_1.DirectiveTokens.open || token.type === types_1.DirectiveTokens.fence) {\n            const directive = getDirective(directives, token.attrGet('kind'));\n            const { name } = (_a = token.meta) === null || _a === void 0 ? void 0 : _a.opts;\n            /* Only number things if:\n             *    * the directive supports numbering\n             *    * AND a name is provided\n             *    * OR autoNumber for the directive is on\n             */\n            if ((directive === null || directive === void 0 ? void 0 : directive.numbered) && (name || (directive === null || directive === void 0 ? void 0 : directive.autoNumber))) {\n                const target = state_1.newTarget(state, name, directive.numbered);\n                token.meta.target = target;\n            }\n        }\n        if (token.type === 'math_block_eqno') {\n            // This is parsed using the markdownTexMath library, and the name comes on the info:\n            const name = token.info;\n            const target = state_1.newTarget(state, name, state_1.TargetKind.equation);\n            token.meta = Object.assign(Object.assign({}, token.meta), { target });\n        }\n    }\n    return true;\n};\nconst plugin = (directives) => (md) => {\n    const { renderer } = md;\n    md.use(markdown_it_container_1.default, 'directives', directiveContainer(directives));\n    md.core.ruler.after('block', 'directive_kind', setDirectiveKind(directives));\n    md.core.ruler.after('directive_kind', 'parse_directive_opts', options_1.default(directives));\n    md.core.ruler.after('parse_directive_opts', 'parse_directive_args', parseArguments(directives));\n    md.core.ruler.after('parse_directive_args', 'numbering', numbering(directives));\n    renderer.rules[types_1.DirectiveTokens.fence] = fenceRenderer(directives);\n};\nexports.plugin = plugin;\n//# sourceMappingURL=plugin.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectiveTokens = void 0;\nvar DirectiveTokens;\n(function (DirectiveTokens) {\n    DirectiveTokens[\"open\"] = \"container_directives_open\";\n    DirectiveTokens[\"close\"] = \"container_directives_close\";\n    DirectiveTokens[\"fence\"] = \"fence_directive\";\n    DirectiveTokens[\"inline\"] = \"inline\";\n})(DirectiveTokens = exports.DirectiveTokens || (exports.DirectiveTokens = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unusedOptionsWarning = void 0;\nconst unusedOptionsWarning = (kind, opts) => {\n    if (Object.keys(opts).length > 0) {\n        console.warn(`Unknown ${kind} options`, opts);\n    }\n};\nexports.unusedOptionsWarning = unusedOptionsWarning;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.directives = exports.roles = exports.plugins = exports.MyST = void 0;\nconst plugins = __importStar(require(\"./plugins\"));\nexports.plugins = plugins;\nconst roles_1 = require(\"./roles\");\nObject.defineProperty(exports, \"roles\", { enumerable: true, get: function () { return roles_1.roles; } });\nconst directives_1 = require(\"./directives\");\nObject.defineProperty(exports, \"directives\", { enumerable: true, get: function () { return directives_1.directives; } });\nvar myst_1 = require(\"./myst\");\nObject.defineProperty(exports, \"MyST\", { enumerable: true, get: function () { return __importDefault(myst_1).default; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// Taken from amsmath version 2.1\n// http://anorien.csc.warwick.ac.uk/mirrors/CTAN/macros/latex/required/amsmath/amsldoc.pdf\nconst ENVIRONMENTS = [\n    // 3.2 single equation with an automatically gen-erated number\n    'equation',\n    // 3.3 variation equation, used for equations that don’t fit on a single line\n    'multline',\n    // 3.5 a group of consecutive equations when there is no alignment desired among them\n    'gather',\n    // 3.6 Used for two or more equations when vertical alignment is desired\n    'align',\n    // allows the horizontal space between equationsto be explicitly specified.\n    'alignat',\n    // stretches the space betweenthe equation columns to the maximum possible width\n    'flalign',\n    // 4.1 The pmatrix, bmatrix, Bmatrix, vmatrix and Vmatrix have (respectively)\n    // (),[],{},||,and ‖‖ delimiters built in.\n    'matrix',\n    'pmatrix',\n    'bmatrix',\n    'Bmatrix',\n    'vmatrix',\n    'Vmatrix',\n    // eqnarray is another math environment, it is not part of amsmath,\n    // and note that it is better to use align or equation+split instead\n    'eqnarray',\n];\n// other \"non-top-level\" environments:\n// 3.4 the split environment is for single equations that are too long to fit on one line\n// and hence must be split into multiple lines,\n// it is intended for use only inside some other displayed equation structure,\n// usually an equation, align, or gather environment\n// 3.7 variants gathered, aligned,and alignedat are provided\n// whose total width is the actual width of the contents;\n// thus they can be used as a component in a containing expression\nconst RE_OPEN = new RegExp(`^\\\\\\\\begin{(${ENVIRONMENTS.join('|')})([*]?)}`);\nfunction matchEnvironment(string) {\n    const matchOpen = string.match(RE_OPEN);\n    if (!matchOpen)\n        return null;\n    const [, environment, numbered] = matchOpen;\n    const end = `\\\\end{${environment}${numbered}}`;\n    const matchClose = string.indexOf(end);\n    if (matchClose === -1)\n        return null;\n    return { environment, numbered, endpos: matchClose + end.length };\n}\nfunction amsmathBlock(state, startLine, endLine, silent) {\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4)\n        return false;\n    const begin = state.bMarks[startLine] + state.tShift[startLine];\n    const outcome = matchEnvironment(state.src.slice(begin));\n    if (!outcome)\n        return false;\n    const { environment, numbered } = outcome;\n    let { endpos } = outcome;\n    endpos += begin;\n    let line = startLine;\n    while (line < endLine) {\n        if (endpos >= state.bMarks[line] && endpos <= state.eMarks[line]) {\n            // line for end of block math found ...\n            // eslint-disable-next-line no-param-reassign\n            state.line = line + 1;\n            break;\n        }\n        line += 1;\n    }\n    if (!silent) {\n        const token = state.push('amsmath', 'math', 0);\n        token.block = true;\n        token.content = state.src.slice(begin, endpos);\n        token.meta = { environment, numbered };\n        token.map = [startLine, line];\n    }\n    return true;\n}\nconst renderAmsmathBlock = (tokens, idx) => {\n    const token = tokens[idx];\n    return utils_1.renderMath(token.content, true);\n};\n/**\n  Parses TeX math equations, without any surrounding delimiters,\n  only for top-level [amsmath](https://ctan.org/pkg/amsmath) environments:\n  ```latex\n    \\begin{gather*}\n      a_1=b_1+c_1\\\\\n      a_2=b_2+c_2-d_2+e_2\n    \\end{gather*}\n  ```\n*/\nfunction amsmathPlugin(md) {\n    const { renderer } = md;\n    md.block.ruler.before('blockquote', 'amsmath', amsmathBlock, { alt: ['paragraph', 'reference', 'blockquote', 'list', 'footnote_def'] });\n    renderer.rules.amsmath = renderAmsmathBlock;\n}\nexports.default = amsmathPlugin;\n//# sourceMappingURL=amsmath.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = exports.addMathRenderers = void 0;\nconst markdown_it_texmath_1 = __importDefault(require(\"markdown-it-texmath\"));\nconst amsmath_1 = __importDefault(require(\"./amsmath\"));\nconst utils_1 = require(\"./utils\");\nfunction addMathRenderers(md) {\n    const { renderer } = md;\n    renderer.rules.math_inline = (tokens, idx) => utils_1.renderMath(tokens[idx].content, false);\n    // Note: this will actually create invalid HTML\n    renderer.rules.math_inline_double = (tokens, idx) => utils_1.renderMath(tokens[idx].content, true);\n    renderer.rules.math_block = (tokens, idx) => utils_1.renderMath(tokens[idx].content, true);\n    renderer.rules.math_block_end = () => '';\n    renderer.rules.math_block_eqno = (tokens, idx) => {\n        var _a;\n        return (utils_1.renderMath(tokens[idx].content, true, (_a = tokens[idx].meta) === null || _a === void 0 ? void 0 : _a.target));\n    };\n    renderer.rules.math_block_eqno_end = () => '';\n}\nexports.addMathRenderers = addMathRenderers;\nfunction plugin(md) {\n    md.use(markdown_it_texmath_1.default, {\n        engine: { renderToString: (s) => s },\n        delimiters: 'dollars',\n    });\n    amsmath_1.default(md);\n    // Note: numbering of equations for `math_block_eqno` happens in the directives rules\n    addMathRenderers(md);\n}\nexports.plugin = plugin;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderMath = void 0;\nconst utils_1 = require(\"../utils\");\nconst renderMath = (math, block, target) => {\n    const { id, number } = target !== null && target !== void 0 ? target : {};\n    const [html] = utils_1.toHTML([block ? 'div' : 'span', {\n            class: target ? ['math', 'numbered'] : 'math',\n            id,\n            number,\n            children: block ? `\\\\[\\n${math}\\n\\\\]` : `\\\\(${math}\\\\)`,\n        }], { inline: true });\n    return block ? `${html}\\n` : html;\n};\nexports.renderMath = renderMath;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = void 0;\nconst markdown_it_1 = __importDefault(require(\"markdown-it\"));\nconst plugins = __importStar(require(\"./plugins\"));\nconst directives_1 = require(\"./directives\");\nconst roles_1 = require(\"./roles\");\nexports.defaultOptions = {\n    directives: directives_1.directives,\n    roles: roles_1.roles,\n    math: true,\n    markdownit: { html: false },\n};\nfunction MyST(opts = exports.defaultOptions) {\n    const tokenizer = markdown_it_1.default('commonmark', opts.markdownit);\n    if (opts.math)\n        tokenizer.use(plugins.math);\n    tokenizer.use(plugins.blocks);\n    tokenizer.use(plugins.directives(directives_1.directives));\n    tokenizer.use(plugins.roles(roles_1.roles));\n    return tokenizer;\n}\nexports.default = MyST;\n//# sourceMappingURL=myst.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.directives = exports.roles = exports.math = exports.blocks = void 0;\nvar blocks_1 = require(\"./blocks\");\nObject.defineProperty(exports, \"blocks\", { enumerable: true, get: function () { return blocks_1.plugin; } });\nvar math_1 = require(\"./math\");\nObject.defineProperty(exports, \"math\", { enumerable: true, get: function () { return math_1.plugin; } });\nvar roles_1 = require(\"./roles\");\nObject.defineProperty(exports, \"roles\", { enumerable: true, get: function () { return roles_1.plugin; } });\nvar directives_1 = require(\"./directives\");\nObject.defineProperty(exports, \"directives\", { enumerable: true, get: function () { return directives_1.plugin; } });\n//# sourceMappingURL=plugins.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../utils\");\nconst roles = {\n    myst_role: {\n        token: 'myst_role',\n        renderer: (tokens, idx) => {\n            var _a, _b;\n            const token = tokens[idx];\n            const name = (_b = (_a = token.meta) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'unknown';\n            const [html] = utils_1.toHTML([\n                'code',\n                { class: 'myst-role', children: `{${name}}\\`${token.content}\\`` },\n            ], { inline: true });\n            return html;\n        },\n    },\n};\nexports.default = roles;\n//# sourceMappingURL=generic.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../utils\");\nconst ABBR_PATTERN = /^(.+?)\\(([^()]+)\\)$/; // e.g. 'CSS (Cascading Style Sheets)'\nconst roles = {\n    abbr: {\n        token: 'abbr',\n        getAttrs(content) {\n            const match = ABBR_PATTERN.exec(content);\n            if (match == null)\n                return { attrs: { title: null }, content };\n            const [, modified, title] = match;\n            return { attrs: { title: title.trim() }, content: modified.trim() };\n        },\n        renderer: (tokens, idx) => {\n            const token = tokens[idx];\n            const [html] = utils_1.toHTML(['abbr', { title: token.attrGet('title'), children: token.content }], { inline: true });\n            return html;\n        },\n    },\n    sub: {\n        token: 'sub',\n        renderer: (tokens, idx) => {\n            const [html] = utils_1.toHTML(['sub', { children: tokens[idx].content }], { inline: true });\n            return html;\n        },\n    },\n    sup: {\n        token: 'sup',\n        renderer: (tokens, idx) => {\n            const [html] = utils_1.toHTML(['sup', { children: tokens[idx].content }], { inline: true });\n            return html;\n        },\n    },\n};\nexports.default = roles;\n//# sourceMappingURL=html.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = exports.roles = void 0;\nconst html_1 = __importDefault(require(\"./html\"));\nconst math_1 = __importDefault(require(\"./math\"));\nconst references_1 = __importDefault(require(\"./references\"));\nconst generic_1 = __importDefault(require(\"./generic\"));\nexports.roles = Object.assign(Object.assign(Object.assign(Object.assign({}, html_1.default), math_1.default), references_1.default), generic_1.default);\nvar plugin_1 = require(\"./plugin\");\nObject.defineProperty(exports, \"plugin\", { enumerable: true, get: function () { return plugin_1.plugin; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../math/utils\");\nconst roles = {\n    math: {\n        token: 'math_inline',\n        renderer: (tokens, idx) => utils_1.renderMath(tokens[idx].content, false),\n    },\n};\nexports.default = roles;\n//# sourceMappingURL=math.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.plugin = void 0;\nconst generic_1 = __importDefault(require(\"./generic\"));\n// Ported from https://github.com/executablebooks/markdown-it-py/blob/master/markdown_it/extensions/myst_role/index.py\n// MIT License: https://github.com/executablebooks/markdown-it-py/blob/master/LICENSE\n// e.g. {role}`text`\nlet x;\ntry {\n    x = new RegExp('^\\\\{([a-zA-Z_\\\\-+:]{1,36})\\\\}(`+)(?!`)(.+?)(?<!`)\\\\2(?!`)');\n}\ncatch (error) {\n    // Safari does not support negative look-behinds\n    // This is a slightly down-graded, as it does not require a space.\n    x = /^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)\\2(?!`)/;\n}\nconst ROLE_PATTERN = x;\nconst getRoleAttrs = (roles) => (name, content) => {\n    var _a, _b;\n    const roleF = (_a = roles[name]) !== null && _a !== void 0 ? _a : generic_1.default.myst_role;\n    if (roleF.getAttrs) {\n        const { attrs, content: modified } = roleF.getAttrs(content);\n        return { token: roleF.token, attrs: attrs !== null && attrs !== void 0 ? attrs : {}, content: modified !== null && modified !== void 0 ? modified : content };\n    }\n    return { token: roleF.token, attrs: (_b = roleF.attrs) !== null && _b !== void 0 ? _b : {}, content };\n};\nconst addRenderers = (roles) => (md) => {\n    const { renderer } = md;\n    Object.entries(roles).forEach(([, { token, renderer: tokenRenderer }]) => {\n        // Early return if the role is already defined\n        // e.g. math_inline might be better handled by another plugin\n        if (md.renderer.rules[token])\n            return;\n        renderer.rules[token] = tokenRenderer;\n    });\n};\nconst mystRole = (roles) => (state, silent) => {\n    // Check if the role is escaped\n    if (state.src.charCodeAt(state.pos - 1) === 0x5C) { /* \\ */\n        // TODO: this could be improved in the case of edge case '\\\\{'\n        return false;\n    }\n    const match = ROLE_PATTERN.exec(state.src.slice(state.pos));\n    if (match == null)\n        return false;\n    const [str, name, , content] = match;\n    // eslint-disable-next-line no-param-reassign\n    state.pos += str.length;\n    if (!silent) {\n        const role = getRoleAttrs(roles)(name, content);\n        const token = state.push(role.token, '', 0);\n        Object.entries(role.attrs).map(([k, v]) => token.attrSet(k, v));\n        token.meta = { name };\n        token.content = role.content;\n    }\n    return true;\n};\nconst plugin = (roles) => (md) => {\n    md.inline.ruler.before('backticks', 'myst_role', mystRole(roles));\n    addRenderers(roles)(md);\n};\nexports.plugin = plugin;\n//# sourceMappingURL=plugin.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst state_1 = require(\"../state\");\nconst utils_1 = require(\"../utils\");\nconst REF_PATTERN = /^(.+?)<([^<>]+)>$/; // e.g. 'Labeled Reference <ref>'\nconst renderReferenceError = (ref) => {\n    const [html] = utils_1.toHTML([\n        'span', {\n            class: 'error',\n            title: `The reference '${ref}' was not found.`,\n            children: `Reference '${ref}' not found.`,\n        },\n    ], { inline: true });\n    return html;\n};\n/**\n * Renders a reference as an anchor link.\n */\nconst renderReference = (opts) => (tokens, idx, options, env) => {\n    var _a;\n    const token = tokens[idx];\n    const ref = (_a = token.attrGet('ref')) !== null && _a !== void 0 ? _a : '';\n    const target = env.targets[ref];\n    if (!target || (opts.kind && (target === null || target === void 0 ? void 0 : target.kind) !== opts.kind))\n        return renderReferenceError(ref);\n    const { id, title, defaultReference, number, } = target;\n    let text = token.content || title || defaultReference;\n    if (opts.numbered) {\n        // See https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html#role-numref\n        text = text.replace(/%s/g, String(number)).replace(/\\{number\\}/g, String(number));\n    }\n    if (opts.brackets) {\n        text = `${token.content}(${number})`;\n    }\n    const [html] = utils_1.toHTML([\n        'a', {\n            href: `#${id}`,\n            title: title || defaultReference,\n            children: text,\n        },\n    ], { inline: true });\n    return html;\n};\nconst getReferenceAttrs = (content) => {\n    const match = REF_PATTERN.exec(content);\n    if (match == null)\n        return { attrs: { ref: content }, content: '' };\n    const [, modified, ref] = match;\n    return { attrs: { ref: ref.trim() }, content: modified.trim() };\n};\nconst roles = {\n    ref: {\n        token: 'ref',\n        getAttrs: getReferenceAttrs,\n        renderer: renderReference({ numbered: false, brackets: false }),\n    },\n    numref: {\n        token: 'numref',\n        getAttrs: getReferenceAttrs,\n        renderer: renderReference({ numbered: true, brackets: false }),\n    },\n    eq: {\n        token: 'eq',\n        getAttrs: getReferenceAttrs,\n        renderer: renderReference({ numbered: true, brackets: true, kind: state_1.TargetKind.equation }),\n    },\n};\nexports.default = roles;\n//# sourceMappingURL=references.js.map","\"use strict\";\n/* eslint-disable no-param-reassign */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.newTarget = exports.getStateEnv = exports.TargetKind = void 0;\nconst utils_1 = require(\"markdown-it/lib/common/utils\");\nvar TargetKind;\n(function (TargetKind) {\n    TargetKind[\"ref\"] = \"ref\";\n    TargetKind[\"equation\"] = \"eq\";\n    TargetKind[\"figure\"] = \"fig\";\n    TargetKind[\"table\"] = \"table\";\n    TargetKind[\"code\"] = \"code\";\n})(TargetKind = exports.TargetKind || (exports.TargetKind = {}));\nconst RefFormatter = {\n    ref(id) { return `[${id}]`; },\n    eq(id, num) { return `Eq ${num}`; },\n    fig(id, num) { return `Fig ${num}`; },\n    table(id, num) { return `Table ${num}`; },\n    code(id, num) { return `Code ${num}`; },\n};\nfunction getStateEnv(state) {\n    var _a;\n    const env = (_a = state.env) !== null && _a !== void 0 ? _a : {};\n    if (!env.targets)\n        env.targets = {};\n    if (!env.numbering) {\n        env.numbering = {\n            eq: 0,\n            fig: 0,\n            table: 0,\n            code: 0,\n        };\n    }\n    if (!state.env)\n        state.env = env;\n    return env;\n}\nexports.getStateEnv = getStateEnv;\n/** Get the next number for an equation, figure, code or table\n *\n * Can input `{ numbering: { equation: 100 } }` to start counting at a different numebr.\n *\n * @param state MarkdownIt state that will be modified\n */\nfunction nextNumber(state, kind) {\n    if (kind === TargetKind.ref)\n        throw new Error('Targets are not numbered?');\n    const env = getStateEnv(state);\n    env.numbering[kind] += 1;\n    return env.numbering[kind];\n}\n/** Create a new internal target.\n *\n * @param state MarkdownIt state that will be modified\n * @param name The reference name that will be used for the target. Note some directives use label.\n * @param kind The target kind: \"ref\", \"equation\", \"code\", \"table\" or \"figure\"\n */\nfunction newTarget(state, name, kind) {\n    const env = getStateEnv(state);\n    const number = kind === TargetKind.ref ? undefined : nextNumber(state, kind);\n    // TODO: not sure about this - if name is not provided, then you get `fig-1` etc.\n    const useName = name ? utils_1.escapeHtml(name) : `${kind}-${String(number)}`;\n    const id = name ? `${kind}-${utils_1.escapeHtml(useName)}` : useName;\n    const target = {\n        id,\n        name: useName,\n        defaultReference: RefFormatter[kind](id, number),\n        kind,\n        number,\n    };\n    env.targets[useName] = target;\n    return target;\n}\nexports.newTarget = newTarget;\n//# sourceMappingURL=state.js.map","\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toHTML = exports.formatTag = void 0;\nconst utils_1 = require(\"markdown-it/lib/common/utils\");\nconst HTML_EMPTY_ELEMENTS = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\nconst formatAttr = (key, value) => {\n    let v;\n    if (value == null)\n        return null;\n    if (Array.isArray(value)) {\n        v = value.join(' ');\n    }\n    else if (typeof value === 'number') {\n        v = String(value);\n    }\n    else if (typeof value === 'boolean') {\n        if (!value)\n            return null;\n        v = '';\n    }\n    else {\n        v = value;\n    }\n    return `${key}=\"${utils_1.escapeHtml(v)}\"`;\n};\nfunction formatTag(tag, attributes, inline) {\n    const { children } = attributes, rest = __rest(attributes, [\"children\"]);\n    const join = inline ? '' : '\\n';\n    const attrs = Object.entries(rest)\n        .filter(([, value]) => value != null && value !== false)\n        .map(([key, value]) => formatAttr(key, value))\n        .filter((value) => value != null)\n        .join(' ');\n    const html = `<${utils_1.escapeHtml(tag)}${attrs ? ` ${attrs}` : ''}>`;\n    if (children)\n        return `${html}${join}${utils_1.escapeHtml(String(children))}`;\n    return html;\n}\nexports.formatTag = formatTag;\nfunction toHTMLRecurse(template, inline) {\n    // Convert to an internal type which is actually an array\n    const T = template;\n    // Cannot have more than one hole in the template\n    const atMostOneHole = T.flat(Infinity).filter((v) => v === 0).length <= 1;\n    if (!atMostOneHole)\n        throw new Error('There cannot be more than one hole in the template.');\n    // Grab the tag and attributes if they exist!\n    const tag = T[0];\n    const hasAttrs = !Array.isArray(T === null || T === void 0 ? void 0 : T[1]) && typeof (T === null || T === void 0 ? void 0 : T[1]) === 'object';\n    const attrs = hasAttrs ? T[1] : {};\n    // These are the tag arrays before and after the hole.\n    const before = [];\n    const after = [];\n    before.push(formatTag(tag, attrs, inline));\n    let foundHole = false;\n    T.slice(hasAttrs ? 2 : 1).forEach((value) => {\n        const v = value;\n        if (v === 0) {\n            foundHole = true;\n            return;\n        }\n        // Recurse, if a hole is found then split the return\n        const [b, a] = toHTMLRecurse(v, inline);\n        before.push(b);\n        if (a) {\n            foundHole = true;\n            after.push(a);\n        }\n    });\n    const join = inline ? '' : '\\n';\n    const closingTag = HTML_EMPTY_ELEMENTS.has(tag) ? '' : `</${tag}>`;\n    if (!foundHole) {\n        if (closingTag)\n            before.push(closingTag);\n        return [before.join(join), null];\n    }\n    if (closingTag)\n        after.push(closingTag);\n    return [before.join(join), after.join(join)];\n}\n/**\n * A helper function to create valid HTML with a \"hole\" (represented by zero) for content.\n *\n * The content is escaped and null/undefined attributes are not included.\n *\n * **A simple wrapper tag:**\n * ```\n * const attr = 'hello';\n * const html = toHTML(['tag', {attr}, 0]);\n * console.log(html);\n * > ['<tag attr=\"hello\">', '</tag>']\n * ```\n *\n * **A nested wrapper tag:**\n * ```\n * const html = toHTML([\n *  'tag', {attr},\n *  ['img', {src}],\n *  ['caption', 0],\n * ]);\n * console.log(html);\n * > ['<tag attr=\"x\"><img src=\"src\"><caption>', '</caption></tag>']\n * ```\n *\n * You can include `children` in the `attrs` and that adds inline content for a tag.\n *\n * You can also send in a list of strings for `attrs`, which are joined with a space (`' '`).\n *\n * Types are based on prosemirror-model.\n *\n * @param spec The spec for the dom model.\n * @param opts Options dict, `inline` creates HTML that is on a single line.\n */\nfunction toHTML(template, opts = { inline: false }) {\n    const [before, after] = toHTMLRecurse(template, opts.inline);\n    const join = opts.inline ? '' : '\\n';\n    return [`${before}${join}`, after ? `${after}${join}` : null];\n}\nexports.toHTML = toHTML;\n//# sourceMappingURL=utils.js.map","// Process block-level custom containers\n//\n'use strict';\n\n\nmodule.exports = function container_plugin(md, name, options) {\n\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params/*, markup*/) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, slf) {\n\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n\n  options = options || {};\n\n  var min_markers = 3,\n      marker_str  = options.marker || ':',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length,\n      validate    = options.validate || validateDefault,\n      render      = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, params, token,\n        old_parent, old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n    if (!validate(params, markup)) { return false; }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('container_' + name + '_open', 'div', 1);\n    token.markup = markup;\n    token.block  = true;\n    token.info   = params;\n    token.map    = [ startLine, nextLine ];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token        = state.push('container_' + name + '_close', 'div', -1);\n    token.markup = state.src.slice(start, pos);\n    token.block  = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n};\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Stefan Goessner - 2017-20. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\n\r\nfunction texmath(md, options) {\r\n    const delimiters = options && options.delimiters || 'dollars';\r\n    const katexOptions = options && options.katexOptions || { throwOnError: false };\r\n    katexOptions.macros = options && options.macros || katexOptions.macros;  // ensure backwards compatibility\r\n\r\n    if (!texmath.katex) { // else ... depricated `use` method was used ...\r\n        if (options && typeof options.engine === 'object') {\r\n            texmath.katex = options.engine;\r\n        }\r\n        else if (typeof module === \"object\")\r\n            texmath.katex = require('katex');\r\n        else  // artifical error object.\r\n            texmath.katex = { renderToString() { return 'No math renderer found.' } };\r\n    }\r\n\r\n    if (delimiters in texmath.rules) {\r\n        for (const rule of texmath.rules[delimiters].inline) {\r\n            md.inline.ruler.before('escape', rule.name, texmath.inline(rule));  // ! important\r\n            md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\\$1/,texmath.render(tokens[idx].content,!!rule.displayMode,katexOptions));\r\n        }\r\n\r\n        for (const rule of texmath.rules[delimiters].block) {\r\n            md.block.ruler.before('fence', rule.name, texmath.block(rule));  // ! important for ```math delimiters\r\n            md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\\$2/,tokens[idx].info)  // equation number .. ?\r\n                                                                     .replace(/\\$1/,texmath.render(tokens[idx].content,true,katexOptions));\r\n        }\r\n    }\r\n}\r\n\r\n// texmath.inline = (rule) => dollar;  // just for debugging/testing ..\r\n\r\ntexmath.inline = (rule) => \r\n    function(state, silent) {\r\n        const pos = state.pos;\r\n        const str = state.src;\r\n        const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, pos));  // valid pre-condition ...\r\n        const match = pre && rule.rex.exec(str);\r\n        const res = !!match && pos < rule.rex.lastIndex && (!rule.post || rule.post(str, rule.rex.lastIndex - 1));\r\n\r\n        if (res) { \r\n            if (!silent) {\r\n                const token = state.push(rule.name, 'math', 0);\r\n                token.content = match[1];\r\n                token.markup = rule.tag;\r\n            }\r\n            state.pos = rule.rex.lastIndex;\r\n        }\r\n        return res;\r\n    }\r\n\r\ntexmath.block = (rule) => \r\n    function block(state, begLine, endLine, silent) {\r\n        const pos = state.bMarks[begLine] + state.tShift[begLine];\r\n        const str = state.src;\r\n        const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, pos));  // valid pre-condition ....\r\n        const match = pre && rule.rex.exec(str);\r\n        const res = !!match\r\n                 && pos < rule.rex.lastIndex \r\n                 && (!rule.post || rule.post(str, rule.rex.lastIndex - 1));\r\n\r\n        if (res && !silent) {    // match and valid post-condition ...\r\n            const endpos = rule.rex.lastIndex - 1;\r\n            let curline;\r\n\r\n            for (curline = begLine; curline < endLine; curline++)\r\n                if (endpos >= state.bMarks[curline] + state.tShift[curline] && endpos <= state.eMarks[curline]) // line for end of block math found ...\r\n                    break;\r\n\r\n            // \"this will prevent lazy continuations from ever going past our end marker\"\r\n            // s. https://github.com/markdown-it/markdown-it-container/blob/master/index.js\r\n            const lineMax = state.lineMax;\r\n            const parentType = state.parentType;\r\n            state.lineMax = curline;\r\n            state.parentType = 'math';\r\n\r\n            if (parentType === 'blockquote') // remove all leading '>' inside multiline formula\r\n                match[1] = match[1].replace(/(\\n*?^(?:\\s*>)+)/gm,'');\r\n            // begin token\r\n            let token = state.push(rule.name, 'math', 1);  // 'math_block'\r\n            token.block = true;\r\n            token.markup = rule.tag;\r\n            token.content = match[1];\r\n            token.info = match[match.length-1];    // eq.no\r\n            token.map = [ begLine, curline ];\r\n            // end token\r\n            token = state.push(rule.name+'_end', 'math', -1);\r\n            token.block  = true;\r\n            token.markup = rule.tag;\r\n\r\n            state.parentType = parentType;\r\n            state.lineMax = lineMax;\r\n            state.line = curline+1;\r\n        }\r\n        return res;\r\n    }\r\n\r\ntexmath.render = function(tex,displayMode,options) {\r\n    options.displayMode = displayMode;\r\n    let res;\r\n    try {\r\n        res = texmath.katex.renderToString(tex, options);\r\n    }\r\n    catch(err) {\r\n        res = tex+\": \"+err.message.replace(\"<\",\"&lt;\");\r\n    }\r\n    return res;\r\n}\r\n\r\n// ! deprecated ... use options !\r\ntexmath.use = function(katex) {  // math renderer used ...\r\n    texmath.katex = katex;       // ... katex solely at current ...\r\n    return texmath;\r\n}\r\n\r\n/*\r\nfunction dollar(state, silent) {\r\n  var start, max, marker, matchStart, matchEnd, token,\r\n      pos = state.pos,\r\n      ch = state.src.charCodeAt(pos);\r\n\r\n  if (ch !== 0x24) { return false; }  // $\r\n\r\n  start = pos;\r\n  pos++;\r\n  max = state.posMax;\r\n\r\n  while (pos < max && state.src.charCodeAt(pos) === 0x24) { pos++; }\r\n\r\n  marker = state.src.slice(start, pos);\r\n\r\n  matchStart = matchEnd = pos;\r\n\r\n  while ((matchStart = state.src.indexOf('$', matchEnd)) !== -1) {\r\n    matchEnd = matchStart + 1;\r\n\r\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x24) { matchEnd++; }\r\n\r\n    if (matchEnd - matchStart === marker.length) {\r\n      if (!silent) {\r\n        token         = state.push('math_inline', 'math', 0);\r\n        token.markup  = marker;\r\n        token.content = state.src.slice(pos, matchStart)\r\n                                 .replace(/[ \\n]+/g, ' ')\r\n                                 .trim();\r\n      }\r\n      state.pos = matchEnd;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (!silent) { state.pending += marker; }\r\n  state.pos += marker.length;\r\n  return true;\r\n};\r\n*/\r\n\r\n// used for enable/disable math rendering by `markdown-it`\r\ntexmath.inlineRuleNames = ['math_inline','math_inline_double'];\r\ntexmath.blockRuleNames  = ['math_block','math_block_eqno'];\r\n\r\ntexmath.$_pre = (str,beg) => {\r\n    const prv = beg > 0 ? str[beg-1].charCodeAt(0) : false;\r\n    return !prv || prv !== 0x5c                // no backslash,\r\n                && (prv < 0x30 || prv > 0x39); // no decimal digit .. before opening '$'\r\n}\r\ntexmath.$_post = (str,end) => {\r\n    const nxt = str[end+1] && str[end+1].charCodeAt(0);\r\n    return !nxt || nxt < 0x30 || nxt > 0x39;   // no decimal digit .. after closing '$'\r\n}\r\n\r\ntexmath.rules = {\r\n    brackets: {\r\n        inline: [ \r\n            {   name: 'math_inline',\r\n                rex: /\\\\\\((.+?)\\\\\\)/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '\\\\('\r\n            }\r\n        ],\r\n        block: [\r\n            {   name: 'math_block_eqno',\r\n                rex: /\\\\\\[(((?!\\\\\\]|\\\\\\[)[\\s\\S])+?)\\\\\\]\\s*?\\(([^)$\\r\\n]+?)\\)/gmy,\r\n                tmpl: '<section class=\"eqno\"><eqn>$1</eqn><span>($2)</span></section>',\r\n                tag: '\\\\['\r\n            },\r\n            {   name: 'math_block',\r\n                rex: /\\\\\\[([\\s\\S]+?)\\\\\\]/gmy,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '\\\\['\r\n            }\r\n        ]\r\n    },\r\n    gitlab: {\r\n        inline: [ \r\n            {   name: 'math_inline',\r\n                rex: /\\$`(.+?)`\\$/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '$`'\r\n            }\r\n        ],\r\n        block: [\r\n            {   name: 'math_block_eqno',\r\n                rex: /`{3}math\\s*([^`]+?)\\s*?`{3}\\s*\\(([^)\\r\\n]+?)\\)/gm,\r\n                tmpl: '<section class=\"eqno\"><eqn>$1</eqn><span>($2)</span></section>',\r\n                tag: '```math'\r\n            },\r\n            {   name: 'math_block',\r\n                rex: /`{3}math\\s*([^`]*?)\\s*`{3}/gm,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '```math'\r\n            }\r\n        ]\r\n    },\r\n    julia: {\r\n        inline: [ \r\n            {   name: 'math_inline', \r\n                rex: /`{2}([^`]+?)`{2}/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '``'\r\n            },\r\n            {   name: 'math_inline',\r\n                rex: /\\$((?:\\S?)|(?:\\S.*?\\S))\\$/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '$',\r\n                pre: texmath.$_pre,\r\n                post: texmath.$_post\r\n            }\r\n        ],\r\n        block: [\r\n            {   name: 'math_block_eqno',\r\n                rex: /`{3}math\\s+?([^`]+?)\\s+?`{3}\\s*?\\(([^)$\\r\\n]+?)\\)/gmy,\r\n                tmpl: '<section class=\"eqno\"><eqn>$1</eqn><span>($2)</span></section>',\r\n                tag: '```math'\r\n            },\r\n            {   name: 'math_block',\r\n                rex: /`{3}math\\s+?([^`]+?)\\s+?`{3}/gmy,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '```math'\r\n            }\r\n        ]\r\n    },\r\n    kramdown: {\r\n        inline: [ \r\n            {   name: 'math_inline', \r\n                rex: /\\${2}(.+?)\\${2}/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '$$'\r\n            }\r\n        ],\r\n        block: [\r\n            {   name: 'math_block_eqno',\r\n                rex: /\\${2}([^$]+?)\\${2}\\s*?\\(([^)\\s]+?)\\)/gmy,\r\n                tmpl: '<section class=\"eqno\"><eqn>$1</eqn><span>($2)</span></section>',\r\n                tag: '$$'\r\n            },\r\n            {   name: 'math_block',\r\n                rex: /\\${2}([^$]+?)\\${2}/gmy,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '$$'\r\n            }\r\n        ]\r\n    },\r\n    dollars: {\r\n        inline: [\r\n            {   name: 'math_inline_double',\r\n                rex: /\\${2}((?:\\S)|(?:\\S.*?\\S))\\${2}/gy,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '$$',\r\n                displayMode: true,\r\n                pre: texmath.$_pre,\r\n                post: texmath.$_post\r\n            },\r\n            {   name: 'math_inline',\r\n                rex: /\\$((?:\\S)|(?:\\S.*?\\S))\\$/gy,\r\n                tmpl: '<eq>$1</eq>',\r\n                tag: '$',\r\n                pre: texmath.$_pre,\r\n                post: texmath.$_post\r\n            }\r\n        ],\r\n        block: [\r\n            {   name: 'math_block_eqno',\r\n                rex: /\\${2}([^$]+?)\\${2}\\s*?\\(([^)\\s]+?)\\)/gmy,\r\n                tmpl: '<section class=\"eqno\"><eqn>$1</eqn><span>($2)</span></section>',\r\n                tag: '$$'\r\n            },\r\n            {   name: 'math_block',\r\n                rex: /\\${2}([^$]+?)\\${2}/gmy,\r\n                tmpl: '<section><eqn>$1</eqn></section>',\r\n                tag: '$$'\r\n            }\r\n        ]\r\n    }\r\n};\r\n\r\nif (typeof module === \"object\" && module.exports)\r\n   module.exports = texmath;"],"sourceRoot":""}